# li-http

> Create HTTP methods for use in LI Frontend applications

> TL'DR - copy and paste the [boilerplate](./etc/boilerplate.js)

Create only the http methods your application needs.
Each method by default will include the appropriate token and impersonate
headers required to communicate with our backend APIs. Response data is
automatically parsed from the response content-type header, so you will never
need to specify "json" or "text" or deal with Fetch's weird intermediary
response promise.

## Installation

```sh
npm i -S li-http
```

## Table of Contents

* [Installation](#installation)
* [Usage](#usage)
* [Method Signatures](#method-signatures)
* [Adding Additional Headers](#adding-additional-headers)
* [Middleware](#middleware)
  * [401 Handler](#401-handler)
  * [Error Parser](#error-parser)

## Usage

Import `createMethod` to create only the http methods your app
needs:

```js
// TIP: in AppShell apps pull this from { _auth } from 'label-insight-app-shell'
import Auth from 'label-insight-auth'
import { init } from 'li-http/lib'

const createMethod = init({
  auth: new Auth({ env: global.EXAMPLE_ENV }),
})

export const get = createMethod('get')
export const post = createMethod('post')
export const put = createMethod('put')
export const del = createMethod('delete')

export default {
  get,
  post,
  put,
  del,
}
```

Request stuff

```js
export const getImage = productId =>
  get(`${api}/product/id/${productId}/images`)

export const getAllImages = productIds =>
  post(`${api}/product/primary/images`, { productIds })
```

## Method Signatures

#### `get|put|delete(url: string): Promise<ResponseData>`

#### `post(url: string, data: JSONSerializable): Promise<ResponseData>`

where `ResponseData` is `string|Object|Response`

## Adding Additional Headers

At method creation time, you can supply additional headers that will be
included in all requests for that method. These must be supplied
via function.

```js
const extendHeaders = headers => ({ ...headers, 'x-foo': 'foo' })

const getWithXFoo = createMethod('get', extendHeaders)
```

## Middleware

Internally, when fetch is called, its `then` callback is fed
an array of response handlers. By default this array consists of
a single default handler. Successful requests will only receive the json
data or text, while rejected methods (those where `!response.ok`) will
reject with the entire response object.
If you need access to the full response object after _successful_ requests,
this will not suffice. Fortunately you can wrap or completely replace the
default handler:

```js
import { middlewares } from 'li-http'

const defaultHandler = middleware.pop()

// wrapping original handler
middlewares.push(response =>
  defaultHandler(response).then(data => ({
    data,
    response,
  }))
)

// otherwise you can replace the default handler entirely
middlewares[0] = response => {
  /* ... */
}
```

### 401 Handler

Prepend this guy to the middleware stack.

```js
// @flow
import { middlewares, create401Handler } from 'li-http/lib'
import { browserHistory } from 'react-router'
import store from './store'

const handle401 = create401Handler(() => store, browserHistory)

middlewares.unshift(handle401)
```

If a 401 occurs at any time, the user will be logged out, removed from the
redux store, and finally redirected to `/login`.

**Note**: ReactBoilerplate based projects may have trouble importing an
instantiated `store` object without significant refactoring. A quick hack
is to add it to the window:

```js
// ./main.js
const store = createStore()
window.__STORE__ = store

// ./http.js
const handle401 = create401Handler(() => window.__STORE__, browserHistory)
```

### Error Parser

By default if a response is not ok, the response will be rejected immediately.
Unfortunately this means you'd have to await the async `error.json` or `error.text`
in your catch blocks:

```js
try {
  await get('/api-that-throws')
} catch (rejected) {
  rejected instanceof Response // true
  // no rejected.message :(
  // just rejected.status|statusText
}
```

Adding the `errorParser` middleware will modify that response by adding
a `serverResponse` property. The serverResponse property will always be an object
and can take one of the following forms depending on the response content type header:

* text or html: `{ message: String }`
* json: whatever the server sent, json parsed. Hopefully your APIs follow the `{ message: String }` convention
* otherwise: `{}` (empty object)

| _NOTE:_ errorParser must come first in the middleware chain!

```js
import { middlewares, errorParser } from 'li-http/lib'

middlewares.unshift(errorParser)

try {
  await get('/api-that-throws')
} catch (rejected) {
  alert(rejected.serverResponse.message)
}
```
